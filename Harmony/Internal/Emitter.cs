using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.InteropServices;

namespace HarmonyLib
{
    internal class LeaveTry
    {
        public override string ToString()
        {
            return "(autogenerated)";
        }
    }

    internal static class Emitter
    {
        private static readonly GetterHandler<ILGenerator, int> codeLenGetter =
            FastAccess.CreateFieldGetter<ILGenerator, int>("code_len", "m_length");

        private static readonly GetterHandler<ILGenerator, LocalBuilder[]> localsGetter =
            FastAccess.CreateFieldGetter<ILGenerator, LocalBuilder[]>("locals");

        internal static string CodePos(int offset)
        {
            return $"L_{offset:x4}: ";
        }

        internal static string CodePos(ILGenerator il)
        {
            var offset = codeLenGetter(il);
            return CodePos(offset);
        }

        internal static void LogComment(ILGenerator il, string comment)
        {
            var str = $"{CodePos(il)}// {comment}";
            FileLog.LogBuffered(str);
        }

        internal static void LogIL(ILGenerator il, OpCode opCode, object argument)
        {
            if (Harmony.DEBUG)
            {
                var argStr = FormatArgument(argument);
                var space = argStr.Length > 0 ? " " : "";
                FileLog.LogBuffered($"{CodePos(il)}{opCode}{space}{argStr}");
            }
        }

        internal static LocalBuilder[] AllLocalVariables(ILGenerator il)
        {
            return localsGetter != null ? localsGetter(il) : new LocalBuilder[0];
        }

        internal static void LogLocalVariable(LocalBuilder variable)
        {
            if (Harmony.DEBUG)
            {
                var str =
                    $"{CodePos(0)}Local var {variable.LocalIndex}: {variable.LocalType.FullName}{(variable.IsPinned ? "(pinned)" : "")}";
                FileLog.LogBuffered(str);
            }
        }

        internal static string FormatArgument(object argument)
        {
            if (argument == null) return "NULL";
            var type = argument.GetType();

            if (argument is MethodInfo method)
                return method.FullDescription();

            if (type == typeof(string))
                return "\"" + argument + "\"";
            if (type == typeof(Label))
                return "Label" + ((Label) argument).GetHashCode();
            if (type == typeof(Label[]))
                return "Labels" + string.Join(
                           ",", ((Label[]) argument).Select(l => l.GetHashCode().ToString()).ToArray());
            if (type == typeof(LocalBuilder))
                return ((LocalBuilder) argument).LocalIndex + " (" + ((LocalBuilder) argument).LocalType + ")";

            return argument.ToString().Trim();
        }

        internal static void MarkLabel(ILGenerator il, Label label)
        {
            if (Harmony.DEBUG) FileLog.LogBuffered(CodePos(il) + FormatArgument(label));
            il.MarkLabel(label);
        }

        internal static void MarkBlockBefore(ILGenerator il, ExceptionBlock block, out Label? label)
        {
            label = null;
            switch (block.blockType)
            {
                case ExceptionBlockType.BeginExceptionBlock:
                    if (Harmony.DEBUG)
                    {
                        FileLog.LogBuffered(".try");
                        FileLog.LogBuffered("{");
                        FileLog.ChangeIndent(1);
                    }

                    label = il.BeginExceptionBlock();
                    return;

                case ExceptionBlockType.BeginCatchBlock:
                    if (Harmony.DEBUG)
                    {
                        // fake log a LEAVE code since BeginCatchBlock() does add it
                        LogIL(il, OpCodes.Leave, new LeaveTry());

                        FileLog.ChangeIndent(-1);
                        FileLog.LogBuffered("} // end try");

                        FileLog.LogBuffered(".catch " + block.catchType);
                        FileLog.LogBuffered("{");
                        FileLog.ChangeIndent(1);
                    }

                    il.BeginCatchBlock(block.catchType);
                    return;

                case ExceptionBlockType.BeginExceptFilterBlock:
                    if (Harmony.DEBUG)
                    {
                        // fake log a LEAVE code since BeginCatchBlock() does add it
                        LogIL(il, OpCodes.Leave, new LeaveTry());

                        FileLog.ChangeIndent(-1);
                        FileLog.LogBuffered("} // end try");

                        FileLog.LogBuffered(".filter");
                        FileLog.LogBuffered("{");
                        FileLog.ChangeIndent(1);
                    }

                    il.BeginExceptFilterBlock();
                    return;

                case ExceptionBlockType.BeginFaultBlock:
                    if (Harmony.DEBUG)
                    {
                        // fake log a LEAVE code since BeginCatchBlock() does add it
                        LogIL(il, OpCodes.Leave, new LeaveTry());

                        FileLog.ChangeIndent(-1);
                        FileLog.LogBuffered("} // end try");

                        FileLog.LogBuffered(".fault");
                        FileLog.LogBuffered("{");
                        FileLog.ChangeIndent(1);
                    }

                    il.BeginFaultBlock();
                    return;

                case ExceptionBlockType.BeginFinallyBlock:
                    if (Harmony.DEBUG)
                    {
                        // fake log a LEAVE code since BeginCatchBlock() does add it
                        LogIL(il, OpCodes.Leave, new LeaveTry());

                        FileLog.ChangeIndent(-1);
                        FileLog.LogBuffered("} // end try");

                        FileLog.LogBuffered(".finally");
                        FileLog.LogBuffered("{");
                        FileLog.ChangeIndent(1);
                    }

                    il.BeginFinallyBlock();
                    return;
            }
        }

        internal static void MarkBlockAfter(ILGenerator il, ExceptionBlock block)
        {
            if (block.blockType == ExceptionBlockType.EndExceptionBlock)
            {
                if (Harmony.DEBUG)
                {
                    // fake log a LEAVE code since BeginCatchBlock() does add it
                    LogIL(il, OpCodes.Leave, new LeaveTry());

                    FileLog.ChangeIndent(-1);
                    FileLog.LogBuffered("} // end handler");
                }

                il.EndExceptionBlock();
            }
        }

        internal static void Emit(ILGenerator il, OpCode opcode)
        {
            if (Harmony.DEBUG) FileLog.LogBuffered(CodePos(il) + opcode);
            il.Emit(opcode);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, LocalBuilder local)
        {
            LogIL(il, opcode, local);
            il.Emit(opcode, local);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, FieldInfo field)
        {
            LogIL(il, opcode, field);
            il.Emit(opcode, field);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, Label[] labels)
        {
            LogIL(il, opcode, labels);
            il.Emit(opcode, labels);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, Label label)
        {
            LogIL(il, opcode, label);
            il.Emit(opcode, label);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, string str)
        {
            LogIL(il, opcode, str);
            il.Emit(opcode, str);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, float arg)
        {
            LogIL(il, opcode, arg);
            il.Emit(opcode, arg);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, byte arg)
        {
            LogIL(il, opcode, arg);
            il.Emit(opcode, arg);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, sbyte arg)
        {
            LogIL(il, opcode, arg);
            il.Emit(opcode, arg);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, double arg)
        {
            LogIL(il, opcode, arg);
            il.Emit(opcode, arg);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, int arg)
        {
            LogIL(il, opcode, arg);
            il.Emit(opcode, arg);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, MethodInfo meth)
        {
            LogIL(il, opcode, meth);
            il.Emit(opcode, meth);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, short arg)
        {
            LogIL(il, opcode, arg);
            il.Emit(opcode, arg);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, SignatureHelper signature)
        {
            LogIL(il, opcode, signature);
            il.Emit(opcode, signature);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, ConstructorInfo con)
        {
            LogIL(il, opcode, con);
            il.Emit(opcode, con);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, Type cls)
        {
            LogIL(il, opcode, cls);
            il.Emit(opcode, cls);
        }

        internal static void Emit(ILGenerator il, OpCode opcode, long arg)
        {
            LogIL(il, opcode, arg);
            il.Emit(opcode, arg);
        }

        internal static void EmitCall(ILGenerator il, OpCode opcode, MethodInfo methodInfo,
                                      Type[] optionalParameterTypes)
        {
            if (Harmony.DEBUG)
                FileLog.LogBuffered(string.Format("{0}Call {1} {2} {3}", CodePos(il), opcode, methodInfo,
                                                  optionalParameterTypes));
            il.EmitCall(opcode, methodInfo, optionalParameterTypes);
        }

        internal static void EmitCalli(ILGenerator il, OpCode opcode, CallingConvention unmanagedCallConv,
                                       Type returnType, Type[] parameterTypes)
        {
            if (Harmony.DEBUG)
                FileLog.LogBuffered(string.Format("{0}Calli {1} {2} {3} {4}", CodePos(il), opcode, unmanagedCallConv,
                                                  returnType, parameterTypes));
            il.EmitCalli(opcode, unmanagedCallConv, returnType, parameterTypes);
        }

        internal static void EmitCalli(ILGenerator il, OpCode opcode, CallingConventions callingConvention,
                                       Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes)
        {
            if (Harmony.DEBUG)
                FileLog.LogBuffered(string.Format("{0}Calli {1} {2} {3} {4} {5}", CodePos(il), opcode,
                                                  callingConvention, returnType, parameterTypes,
                                                  optionalParameterTypes));
            il.EmitCalli(opcode, callingConvention, returnType, parameterTypes, optionalParameterTypes);
        }
    }
}